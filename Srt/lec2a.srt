MIT OpenCourseWare
http://ocw.mit.edu
6.001 Structure and Interpretation of Computer Programs, Spring 2005 Transcript – 2A: Higher-order Procedures
高阶过程


教授：昨天的内容还算容易
PROFESSOR: Well, yesterday was easy.

你们了解到了所有的编程规则
You learned all of the rules of programming

看样子大家感觉还不错
and lived.

那些几乎是所有的规则了
Almost all of them. 

所以此刻 你们算得上是所谓的---
And so at this point, you're now certified programmers 

认证程序员了
-- it says.

不过 我觉得其实是 嗯
However, I suppose what we did is we, aah,
 
其实只是给你们尝了点甜头
sort of got you a little bit of into an easy state.

此时此刻 你可能还在认为这门课就像用BASIC语言或者Pascal语言的某种奇葩语法写程序
Here, you still believe it's possible that this might be programming in BASIC or Pascal with just a funny syntax.

然而就在今天 这种错觉将会被颠覆
Today, that illusion-- or you can no longer support that belief.

我们即将做的 就是要彻底粉碎这种想法
What we're going to do today is going to completely smash that.
 
接下来 我会先在黑板上写一些程序
So let's start out by writing a few programs on the blackboard 

它们之间有很多相似之处
that have a lot in common with each other

我们要做的是尽可能把它们抽象起来
What we're going to do is try to make them abstractions 

这过程并不如在其它大多数语言中那么显而易见 #TBD
that are not ones that are easy to make in most languages.
 
让我们先从简单的例子开始
Let's start with some very simple ones
  
这些例子在大多数语言中可以很容易地做出抽象
that you can make in most languages.

假设 我有一个求和一组整数的数学表达式
Supposing I want to write the mathematical expression which adds up a bunch of integers.

比如 我写下的这个表达式 --- 以i为索引 求和从a到b的整数
So if I wanted to write down and say the sum from i equal a to b on i.

你们知道用数学公式可以很方便地计算出它的结果
Now, you know that that's an easy thing to compute in a closed form for it,

但重点不在此
and I'm not interested in that.

我想要写一个能够对那些整数求和的程序
But I'm going to write a program that adds up those integers.

我们能够很容易地想到
Well, that's rather easy to do to say 

定义过程SUM-INT 求和从a到b的整数 为---
I want to define the sum of the integers from a to b to be--

接下来有两种可能性
well, it's the following two possibilities.

如果a大于b
If a is greater than b,

那么什么也不必做 答案就是0
well, then there's nothing to be done and the answer is zero.

你要以递归的方式思考问题
This is how you're going to have to think recursively.

比如，假如我知道某个简单情形的答案
You're going to say if I have an easy case that I know the answer to,

就可以直接将其作为结果
just write it down.

否则，我就需要将这个问题简化
Otherwise, I'm going to try to reduce this problem to a simpler problem.

比如在这个程序里
And maybe in this case,

我要简化出一个子问题
I'm going to make a subproblem of the simpler problem 

然后再做一些工作从而得出结果
and then do something to the result. 

所以针对这个程序，最简单的处理方式是
So the easiest way to do this is say that 

将下标，在这里是a
I'm going to add the index, which in this case is a,

加上a+1到b的整数的求和结果
to the result of adding up the integers from a plus 1 to b.

现在你们应该都能看懂这个定义了
Now, at this point, you should have no trouble looking at such a definition.

实际上，总的来说，要想得出这个过程定义还是有一些困难的
Indeed, coming up with such a thing might be a little hard in synthesis,

但要想读明白还是比较容易的
but being able to read it at this point should be easy.

现在我想告诉你们的是
And what it says to you is, well, 

这个是我想要求解的子问题
here is the subproblem I'm going to solve.

我要求和的是
I'm going to try to add up the integers, 

比整个问题的规模少一的整数序列
one fewer integer than I added up for the the whole problem. 

接下来需要求和的整数序列的数目会一个个减少
I'm adding up the one fewer one, 

最后，当这个子问题求解完毕后，只要再加上a
and that subproblem, once I've solved it, I'm going to add a to that, 

就能得到整个问题的答案了
and that will be the answer to this problem.

并且，这里的最简单的情形，我不用做任何处理
And the simplest case, I don't have to do any work.

接下来，我要给出另一个类似的简单问题---
Now, I'm also going to write down another simple one just like this,

以i为下标，求和a到b的整数的平方的数学表达式
which is the mathematical expression, the sum of the square from i equal a to b.

同样的，这个程序也很简单
And again, it's a very simple program. 

实际上，这个程序一开始和刚才是一样的
And indeed, it starts the same way.

如果a大于b，那么答案就是0
If a is greater than b, then the answer is zero. 

显然，你会发现我又把这部分重复写了一遍
And, of course, we're beginning to see that there's something wrong with me writing this down again.

这段程序和之前是相同的
It's the same program. 

这里是a的平方加上a+1到b的平方和
It's the sum of the square of a and the sum of the square of the increment and b.

现在，你们再看看这两个程序，它们几乎是完全一样的
Now, if you look at these things, these programs are almost identical.

并没有太多区别
There's not much to distinguish them.

它们有相同的条件表达式，相同的谓词，相同的推论
They have the same first clause of the conditional and the same predicate and the same consequence, 

并且替代部分也非常的相似
and the alternatives are very similar, too. 

事实上，唯一的一个区别是，这里是a，而这里是a的平方
They only differ by the fact that where here I have a, here, I have the square of a. 

另一个区别，有些无关紧要
The only other difference, but this one's sort of unessential 

是这个过程的名字是sum int（整数的和）
is in the name of this procedure is sum int, 

而这个过程的名字是sum square（平方和）
whereas the name of the procedure is sum square. 

所以这两个程序的区别微乎其微
So the things that vary between these two are very small.

现在来看，如果你重复地写了相同的东西
Now, wherever you see yourself writing the same thing down more than once, 

这就产生了一些问题，你并不应该那样做
there's something wrong, and you shouldn't be doing it.

问题并不在于你重复的劳动带来时间浪费
And the reason is not because it's a waste of time to write something down more than once. 

而是在于里面的一些思想，非常简单的思想
It's because there's some idea here, a very simple idea,

与求和记法相关的思想 -- 就是这一部分 --
which has to do with the sigma notation-- this much-- 

其并不依赖于我待求和的内容
not depending upon what it is I'm adding up.

无论何时，当要设计一个复杂的系统并且要弄明白它时，将问题拆分成尽量多的模块是很重要的，并且每一个模块要能够被独立地解释
And I would like to be able to-- always, whenever trying to make complicated systems and understand them, it's crucial to divide the things up into as many pieces as I can, each of which I understand separately. 

我想要弄明白如何把一堆东西求和，并不依赖于要求和的内容是什么
I would like to understand the way of adding things up independently of what it is I'm adding up

这样我就只需要做一次调试，做一次分析
so I can do that having debugged it once and understood it once 

还能够与其他用户分享这段程序
and having been able to share that among many different uses of it.

接下来，我有另外一个例子
Here, we have another example. 

这是莱布尼茨公式，用来求π/8的值
This is Leibnitz's formula for finding pi over 8.

这一团糟的式子是什么意思？
It's a funny, ugly mess. What is it? 

大致是1/(1*3)+1/(5*7)+1/(7*9)+...这样子
It's something like 1 over 1 times 3 plus 1 over 5 times 7 plus 1 over 9 times 11 plus-- 

有趣的是，根据一些证明，它将收敛到π/8
and for some reason, things like this tend to have interesting values like pi over 8. 

我们能发现什么？
But what do we see here? 

这个程序或多或少和之前的程序相同
It's the same program or almost the same program. 

也是一个求和过程
It's a sum.

我们发现在这个表达式里有一些细微的差别，它的递增的值是4，
So we're seeing the figure notation, although over here, we're dealing with incrementing by 4, so it's a slightly different problem, 

所以我们需要在这里将a加4，就在鼠标所指的这个地方
which means that over here, I have to change a by 4, as you see right over here. 

不是加1了
It's not by 1.

当然，另一个区别是
The other thing, of course, 

在之前的求平方和的程序里的求和项是平方值
is that the thing that's represented by square in the previous sum of squares, 

又或是在求整数和的程序里的求和项是整数本身
or a when adding up the integers. 

在这里，我用了不同的求和项
Well, here, I have a different thing I'm adding up, a different term, 

即1 / (a * (a + 2))
which is 1 over a times a plus 2. 

但是，其余部分的程序是相同的
But the rest of this program is identical. 

总之，每当我们发现有一些过程是相同的
Well, any time we have a bunch of things like this that are identical, 

我们就需要做一些抽象来包含它们
we're going to have to come up with some sort of abstraction to cover them.

回想一下，到目前为止，你们学到的只是一些语法规则
If you think about this, what you've learned so far is the rules of some language, 

一些基本的表达形式，一些组合的方法，抽象的方法，大概就是这些
some primitive, some means of combination, almost all of them, the means of abstraction, almost all of them. 

但是，你们还没学到的是，公共的使用模式
But what you haven't learned is common patterns of usage.

大多时候，你要学习的是一门语言习惯用法
Now, most of the time, you learn idioms when learning a language, 

它是一种有价值的公共模式
which is a common pattern that mean things that are useful to know in a flash. 

如果你是一个FORTRAN程序员，并且富有经验
And if you build a great number of them, if you're a FORTRAN programmer, 

你肯定知道
of course, everybody knows how to-- what do you do, 

比如，如何求某个数列中的最大值
for example, to get an integer which is the biggest integer in something. 

这是经典的问题
It's a classic thing. 

每个FORTRAN程序员都知道怎么做
Every FORTRAN programmer knows how to do that. 

如果你不知道的话，你可能会陷于困境并花很长的时间想出答案
And if you don't know that, you're in real hot water because it takes a long time to think it out. 

然而
However, 

在这门语言中我们想展示给你的
one of the things you can do in this language that we're showing you 

不是"鱼"，而是"渔"
is not only do you know something like that, but you give the knowledge of that a name. 

这就是我们接下来要做的事
And so that's what we're going to be going after right now.

好吧，让我们先看看这些程序的共同点
OK, well, let's see what these things have in common. 

在这里我们有一个看似一般的模式
Right over here we have what appears to be a general pattern, 

它包含了到目前为止所有的例子
a general pattern which covers all of the cases we've seen so far. 

这里定义了一个求和过程
There is a sum procedure, which is being defined. 

它有两个参数，代表求和的下界和上界
It has two arguments, which are a lower bound and an upper bound. 

首先判断下界是否大于上界
The lower bound is tested to be greater than the upper bound, 

如果下界大于上界的话，结果就是0
and if it is greater, then the result is zero. 

否则，我们要对下界做一些处理
Otherwise, we're going to do something to the lower bound, 

也就是下标
which is the index of the conversation, 

将处理后的结果与后面这个过程的结果递归地相加
and add that result to the result of following the procedure recursively 

这个过程的参数是next操作处理后的下界
on our lower bound incremented by some next operation 

以及与之前相同的上界
with the same upper bound as I had before.

这即是公共的模式
So this is a general pattern, 

#TBD (9'58) 我想要做的是
and what I'd like to do is be able to name this general pattern a bit. 

这还挺简单
Well, that's sort of easy, 

因为我要做的事...
because one of the things I'm going to do right now is-- 

数字不是非常特殊的东西
there's nothing very special about numbers. 

数字仅仅是一种数据
Numbers are just one kind of data. 

为各种数据命名看上去也是很合理的事情
It seems to be perfectly reasonable to give all sorts of names to all kinds of data, 

比如说，“过程”
for example, procedures. 

并且当今很多语言都允许使用过程参数
And now many languages allow you have procedural arguments, 

现在，我们即将讨论过程参数
and right now, we're going to talk about procedural arguments. 

它们很容易处理
They're very easy to deal with. 

我们首先不去考虑过程参数，来做一些很特别的事情
And shortly, we'll do some remarkable things that are not like procedural arguments.

这里，定义我们的求和记法
So here, we'll define our sigma notation. 

过程名叫做SUM，参数为term, A, NEXT和B
This is called sum and it takes a term, an A, a next term, and B as arguments. 

所以，它有四个参数
So it takes four arguments, 

这里我写成小写没有特殊的含义
and there was nothing particularly special about me writing this in lowercase. 

我不希望它迷惑你，所以我现在把它改成大写
I hope that it doesn't confuse you, so I'll write it in uppercase right now. 

机器并不关心大小写
The machine doesn't care.

但这两个参数并不同。它们不是数字
But these two arguments are different. These are not numbers. 

它们是对数字进行计算的过程
These are going to be procedures for computing something given a number. 

TERM是这样一个过程，提供它一个下标
Term will be a procedure which, when given an index, 

TERM会计算出这个下标所对应的项的值
produce the value of the term for that index. 

提供NEXT过程一个下标，它会计算出下一个下标
Next will be given an index, which will produce the next index. 

这是用来计数的
This will be for counting. 

这很简单
And it's very simple. 

就是字面的意思
It's exactly what you see. 

如果A大于B，结果就是0
If A is greater than B, then the result is 0. 

否则，结果是TERM应用于A所产生的值与TERM,下一个下标产生的结果的和
Otherwise, it's the sum of term applied to A and the sum of term, next index.

我换个方式写
Let me write it this way. 

现在，首先我要你们看一些东西
Now, I'd like you to see something, first of all. 

我写到黑板这，然后写不下了
I was writing here, and I ran out of space. 

于是我使用了缩进，依据的是整齐打印规则
What I did is I start indenting according to the Pretty-printing rule, 

意思是我把过程的每个参数对齐
which says that I align all of the arguments of the procedure 

这样我就能看清它们的层次
so I can see which ones go together. 

这是我刚才无意识地做下的
And this is just something I do automatically, 

并且我也希望你们学会这样做
and I want you to learn how to do that, too, 

这样你的程序就便于阅读和理解
so your programs can be read and understood.

现在，看看我们有什么
However, what do we have here? 

我们有四个参数：过程、下界的下标、
We have four arguments: the procedure, the lower index- - lower bound index-- 

获得下一个下标的方法，以及上界
the way to get the next index, and the upper bound. 

在递归调用的部分实际上传递的是同一个过程
What's passed along on the recursive call is indeed the same procedure 

因为我再一次需要它了
because I'm going to need it again, 

下一个下标，是用NEXT过程计算出的
the next index, which is using the next procedure to compute it, 

计算下一个下标的过程，我也单独地需要，因为这两者是不同的
the procedure for computing next, which I also have to have separately, and that's different. 

计算下一个下标的过程与下一个下标是不同的
The procedure for computing next is different from the next index, 

下一个下标是next过程应用于上一个下标所产生的结果
which is the result of using next on the last index. 

最后我也需要传递上界
And I also have to pass along the upper bound. 

于是，这就囊括了所有的这些，以及我们写过的其它的漂亮的程序
So this captures both of these and the other nice program that we are playing with.

利用这个，我们就可以很容易地写出SUM的原始实例程序
So using this, we can write down the original program as instances of sum very simply. 

A和B
A and B. 

好吧，我在这需要一个identity（恒等）过程，因为...
Well, I'm going to need an identity procedure here because ,ahh, 

整数的求和需要我在这里对每一个整数计算一次term
the sum of the integers requires me to in this case compute a term for every integer, 

但是这个term过程并不对这个整数做任何改变
but the term procedure doesn't want to do anything to that integer. 

所以关于A的identity过程结果就是A
So the identity procedure on A is A 

写成X或者其它的符号也没关系
or X or whatever, 

接下来，将identity作为sum的term过程
and I want to say the sum of using identity of the term procedure 

用A作为初始下标
and using A as the initial index 

增量器用来获取下一个下标
and the incrementer being the way to get the next index 

B作为上界
and B being the high bound, the upper bound. 

这个过程与这里的SUM-INT过程工作方式相同
This procedure does exactly the same as the sum of the integers over here, 

计算出的答案也相同
computes the same answer.

现在，值得注意的一点是
Now, one thing you should see, of course, 

这里的形式参数写成什么都无所谓
is that there's nothing very special over here about what I used as the formal parameter. 

比如，我可以把它写成X，也没关系
I could have, for example, written this X. It doesn't matter. 

注意到这个X和那个X并不冲突
I just wanted you to see that this name does not conflict with this one at all. 

这是一个内部名称
It's an internal name.

对于第二个过程---平方和，它甚至更简单一些
For the second procedure here, the sum of the squares, it's even a little bit easier. 

我们需要做的仅仅是将平方项加起来
And what do we have to do? Nothing more than add up the squares, 

这个过程会对每个下标生效
this is the procedure that each index will be given, will be given each-- yes. 

每个下标使用这个过程来产生一个项
Each index will have this done to it to get the term. 

它对应了那里的term
That's the thing that maps against term over here. 

然后将A作为下界
Then I have A as the lower bound, 

增量器作为产生下一个项的方法
the incrementer as the next term method, 

B作为上界
and B as the upper bound.

最后，来看看之前的pi sums过程
And finally, just for the thing that we did about pi sums, 

pi-sums是...
pi sums are sort of-- 

用这种方法考虑的话，它简单到明显不过了
well, it's even easier to think about them this way because I don't have to think. 

我要做的其实是把我要累加的每一项从累加过程中独立出来
What I'm doing is separating the thing I'm adding up from the method of doing the addition. 

来看看，比如说，pi-sum A B这个过程
And so we have here, for example, pi sum A B of the sum of things. 

我接下来想要写出这个term过程，但不给它命名
I'm going to write the terms procedure here explicitly without giving it a name. 

用匿名的方式
This is done anonymously. 

如果我只是想一次性的使用它，我并不需要给它一个名字
I don't necessarily have to give a name to something if I just want to use it once.

当然，我可以写出某个表达式来产生一个过程
And, of course, I can write sort of a expression that produces a procedure. 

我这里使用希腊字母的λ，而不是L-A-M-B-D-A的全拼
I'm going to write the Greek lambda letter here instead of L-A-M-B-D-A in general 

免得占用太多黑板的空间
to avoid taking up a lot of space on blackboards. 

可惜，我们的键盘上没有λ键
But unfortunately, we don't have lambda keys on our keyboards. 

或许我们可以说服计算机工业界的朋友意识到（λ键的）重要性
Maybe we can convince our friends in the computer industry that this is an important. 

该lambda过程以i为参数，操作是1除以i与i+2的积
Lambda of i is the quotient of 1 and the product of i and the sum of i 2, 

下标从a开始，
starting at a 

递增方法是以i为参数，将i+4的过程
with the way of incrementing being that procedure of an index i, which adds i to 4, 

b作为上界
and b being the upper bound. 

你可以看到这种记法，将过程用作过程参数，
So you can see that this notation, the invention of the procedure that takes a procedural argument, 

允许我们将很多过程组合成一个
allows us to compress a lot of these procedures into one thing. 

这个过程---sums，蕴含着一系列的思想
This procedure, sums, covers a whole bunch of ideas.

现在考虑一下为什么这是很重要的？
Now, just why is this important? 

它帮助我们将一个问题拆分成两个，实际上，它做到了这点
I tried to say before that it helps us divide a problem into two pieces, and indeed, it does, 

比如说，如果某个人提出了另一个实现这个的方法
for example, if someone came up with a different way of implementing this, 

当然，确实有一个
which, of course, one might. 

比如，一个sum过程的迭代实现
Here, for example, an iterative implementation of sum. 

迭代实现在某种程度上也许比递归实现更好
Iterative implementation for some reason might be better than the recursive implementation. 

但是它还是有很大不同的
But the important thing is that it's different.

如果我现在用黑板上左边的那种方法实现了我的程序
Now, supposing I had written my program this way that you see on the blackboard on the left. 

是的，左边那个程序
That's correct, the left. 

后来，我想要改变“求和”这个方法
Well, then if I want to change the method of addition, 

我就不得不修改这里的每一个程序
then I'd have to change each of these. 

然而，如果我用这里这个方法来实现的话
Whereas if I write them like this that you see here, 

那么“求和”这个方法就被封装在了sum过程里
then the method by which I did the addition is encapsulated in the procedure sum. 

这个分解允许我只需修改程序的一部分
That decomposition allows me to independently change one part of the program 

而不改变用于处理其它问题的那些部分
and prove it perhaps without changing the other part that was written for some of the other cases. 

谢谢，大家有问题吗？
Thank you. Are there any questions? 

那位男士
Yes, sir.

观众：A后面的值会被一个一个遍历的吗……
AUDIENCE: Would you go over next A and next again on--

教授：是的
PROFESSOR: Yes. It's the same problem. 

我确信你们需要花一些时间来想明白
I'm sure you're going to-- you're going to have to work on this. 

如果你第一次见到这种写法的话可能会很困惑
This is hard the first time you've ever seen something like this.

这里的过程是可以命名为一个变量
What I have here is a-- procedures can be named by variables. 

“过程”这个概念并没有特殊的地方
Procedures are not special. 

实际上，sum square也只不过是一个变量，会产生一个值
Actually, sum square is a variable, which has gotten a value,

这就是过程
which is a procedure. 

这里其实是定义sum square为一个参数为A、B的lambda过程
This is define sum square to be lambda of A and B something. 

所以过程可以被命名
So the procedure can be named. 

那样的话，过程就可以被作为参数传递于过程之间
Therefore, they can be passed from one to another, one procedure to another, as arguments. 

在这里，我们做的就是把term过程作为参数传递给sum
Well, what we're doing here is we're passing the procedure term as an argument to sum 

在下一层的递归中也会用到它
just when we get it around in the next recursive.

同样地，我们也将next过程作为参数传递了
Here, we're passing the procedure next as an argument also. 

然而，在这里我们是使用了next过程
However, here we're using the procedure next. 

括号提现了这一点
That's what the parentheses mean. 

我们将next过程应用于变量A来获得A的下一个值
We're applying next to A to get the next value of A. 

如果你想知道next过程映射出了什么
If you look at what next is mapped against, 

你可以这样来考虑
remember that the way you think about this is 

用实际参数代换过程体中的形式参数
that you substitute the arguments for the formal parameters in the body. 

如果你还是困惑的话，就像这样想吧
If you're ever confused, think of the thing that way.

比如在SUM-INT过程中
Well, over here, with sum of the integers. 

我用identity过程代换term过程
I substitute identity for a term 

用1+增量过程代换过程体中的next过程
and 1 plus the incrementer for next in the body. 

在这里我将identity过程应用于了A
Well, the identity procedure on A is what I get here. 

identity过程会被继续传递
Identity is being passed along, 

在这里，我将1+过程应用于了A
and here, I have increment 1 plus being applied to A 

并且1+过程也被传递下去
and 1 plus is being passed along. 

清楚这个情况了吗？
Does that clarify the situation?

观众：我们也可以显式地定义那两个过程，然后再传递它们
AUDIENCE: We could also define explicitly those two functions, then pass them.

教授：当然可以
PROFESSOR: Sure. 

我们的确可以命名这些过程，就如我这里做的一样
What we can do is we could have given names to them, just like I did here. 

实际上，我在这里提供了很多种方式给你们
In fact, I gave you various ways so you could see it, a variety. 

在这里，我定义了这个过程，并传递了它的名字
Here, I define the thing which I passed the name of. 

我用它的名字来引用它
I referenced it by its name. 

实际上这个过程的参数是X，结果也是X
But the thing is, in fact, that procedure, one argument X, which is X. 

identity过程实际上相当于lambda (x) (x)
And the identity procedure is just lambda of X X. 

这里就是这样的
And that's what you're seeing here. 

#TBD在这里，我就给你们写出了它的规范名称
Here, I happened to just write its canonical name there for you to see. 

让我们休息5分钟吧
Is it OK if we take our five-minute break?

正如我说的，计算机用于满足人们的需求
As I said, computers to make people happy, 

而不是让人去满足计算机的需求
not people to make computers happy. 

我们介绍抽象概念的大部分原因
And for the most part, the reason why we introduce all this abstraction stuff 

是为了让程序更易写易读
is to make it so that programs can be more easily written and more easily read. 

让我们用一些关于抽象的例子
Let's try to understand what's the most complicated program we've seen so far 

来理解目前为止我们见到的最复杂的程序
using a little bit of this abstraction stuff.

请看幻灯片
If you look at the slide, 

这是我们昨天介绍的Heron of Alexandria方法，用于计算平方根
this is the Heron of Alexandria's method of computing square roots that we saw yesterday. 

看一下这个程序
And let's see. 

不管怎样，这个程序有一些复杂
Well, in any case, this program is a little complicated. 

现在这种情况下
And at the current state of your thinking, 

你肯定不会看着这个程序说
you just can't look at that and say, 

哦，这个程序的目的真是显而易见
oh, this obviously means something very clear. 

它到底在计算什么一点都不明显
It's not obvious from looking at the program what it's computing. 

在try过程里有一些循环
There's some loop here inside try, 

循环在对y的improvement应用try过程
and a loop does something about trying the improvement of y. 

还有一个叫improve的什么东西
There's something called improve, 

做了一些关于average和除法的什么工作
which does some averaging and quotienting and things like that. 

但是它到底在做什么？
But what's the real idea? 

我们可以弄明白这个程序的目的吗？
Can we make it clear what the idea is? 

我认为我们可以
Well, I think we can. 

我觉得我们可以用之前学到的关于抽象的知识
I think we can use abstraction that we have learned about so far 

来说明它到底在干什么
to clarify what's going on.

现在，我们在数学上有一个对平方根结果的更好猜测
Now, what we have mathematically is a procedure for improving a guess for square roots. 

如果y是平方根的一个猜测值，那么我们有一个函数f
And if y is a guess for a square root, then what we want to get we'll call a function f. 

用来改进猜测值
This is the means of improvement. 

我用(y+x/y)/2的结果作为改进的平方根猜测值
I want to get y plus x/y over 2, so the average of y and x divided by y as the improved value for the square root of x 

值得注意的一点是，f对根号x的求值结果就是根号x
such that-- one thing you can notice about this function f is that f of the square root of f is in fact the square root of x. 

因为，如果在这里我将y替换成根号x
In other words, if I take the square root of x and substitute it for y here, 

将会得到根号x加上x与根号x的商
I see the square root of x plus x divided by the square of x, which is the square root of x. 

是2倍根号x除以2，结果就是根号x
That's 2 times the square root of x divided by 2, is the square root of x.

所以，实际上我们在寻找函数f的一个不动点
So, in fact, what we're really looking for is we're looking for a fixed point, a fixed point of the function f. 

不动点就是一个值，将其应用到函数中，得到的还是原来的值
A fixed point is a place which has the property that if you put it into the function, you get the same value out. 

假设你在上一堂很无聊的课
Now, I suppose if I were giving some nice, boring lecture, 

碰巧你面前有一个HP-35计算器
and you happened to have in front of you an HP-35 desk calculator 

我过去就在无聊的课上用过
like I used to have when I went to boring lectures. 

如果你觉得无事可干
And if you think it was really boring, 

你可以进入弧度模式，不停地按cos键，按cos键，按cos键……
you put it into radians mode, and you hit cosine, and you hit cosine, and you hit cosine. 

最终，你将会停在大概是0.734这个值，我记不太清了
And eventually, you end up with 0.734 or something like that. 0.743, I don't remember what exactly, 

越来越接近那个值
and it gets closer and closer to that. 

你可以通过迭代的方法找到一些函数的不动点
Some functions have the property that you can find their fixed point by iterating the function, 

实际上在海伦方法中发生的就是这个过程
and that's essentially what's happening in the square root program by Heron's method.

现在看看我们能不能实现这个想法
So let's see if we can write that down, that idea. Now, 

我不打算讲如何计算出不动点
I'm not going to say how I compute fixed points yet. 

那可以有很多种方法
There might be more than one way. 

首先让我们回到刚才的话题上
But the first thing to do is I'm going to say what I just said. 

回到平方根这个问题上
I'm going to say it specifically, the square root. 

x的平方根是一个过程的不动点
The square root of x is the fixed point of that procedure 

这个过程以y作为参数，计算出x/y和y的平均值
which takes an argument y and averages of x divided by y with y. 

并且假定初始不动点的猜测值为1
And we're going to start up with the initial guess for the fixed point of 1. 

初始值为几都无所谓
It doesn't matter where it starts. 

对于平方根在理论上证明过了
A theorem having to do with square roots.

在这里我仅仅是按愿望思维写出了程序
So what you're seeing here is I'm just trying to write out by wishful thinking. 

我并不知道求不动点的具体细节
I don't know how I'm going to make fixed point happen. 

这点我们接下来再涉及
We'll worry about that later. 

假如我写出了一个求这个过程的不动点的函数
But if somehow I had a way of finding the fixed point of the function computed by this procedure, 

那么我就能得到平方根的值了
then I would have-- that would be the square root that I'm looking for.

现在，我们来看看如何求不动点
OK, well, now let's see how we're going to write-- how we're going to come up with fixed points. 

实际上这很简单
Well, it's very simple, actually. 

我先写出一个简单的版本便于大家理解
I'm going to write an abbreviated version here just so we understand it. 

我要找到函数f的不动点a
I'm going to find the fixed point of a function f-- 

在这个过程里，求不动点的函数我们命名为f
actually, the fixed point of the function computed by the procedure whose name will be f in this procedure. 

接下来，需要一个具体的值开始计算
How's that? A long sentence-- starting with a particular starting value.

在过程内部需要一些循环
Well, I'm going to have a little loop inside here, 

代表了不停地在计算器上按键的过程
which is going to push the button on the calculator repeatedly, 

期待它最终会收敛到一点
hoping that it will eventually converge. 

内部的循环我们定义为内部过程
And we will say here internal loops are written by defining internal procedures. 

在这里，我需要确定我是否找到了我需要的值
Well, one thing I'm going to have to do is I'm going to have to say whether I'm done. 

判断这个的方法是考察旧值与新值是否足够接近，以至于无法区分
And the way I'm going to decide when I'm done is when the old value and the new value are close enough so I can't distinguish them anymore. 

相当于你在计算器上看到结果的变化最终超出了精度范围
That's the standard thing you do on the calculator unless you look at more precision, and eventually, you run out of precision.

所以，这里需要旧值和新值
So the old value and new value, 

并且如果它们足够接近
and I'm going to stay here if I can't distinguish them if they're close enough, 

接下来的操作我马上会提到
and we'll have to worry about what that is soon. 

如果旧值和新值足够接近的话
The old value and the new value are close enough to each other 

我们就选择新值作为结果
and let's pick the new value as the answer. 

否则，我继续迭代这个过程
Otherwise, I'm going to iterate around again 

将当前的新值作为下一轮的旧值
with the next value of old being the current value of new 

将f作用于新值的结果作为下一轮的新值
and the next value of new being the result of calling f on new. 

相当于我不停地按下计算器的键
And so this is my iteration loop that pushes the button on the calculator. 

我可以想象计算器中有两个寄存器：旧与新
I basically think of it as having two registers on the calculator: old and new. 

在每一步中，新值成为旧值，f作用后的新值成为新的新值
And in each step, new becomes old, and new gets F of new. 

这就是得到下一个猜测值的方法
So this is the thing where I'm getting the next value.

现在，我传入两个值来调用这个方法
And now, I'm going to start this thing up by giving two values. 

我详细地在黑板上写出了每一个步骤
I wrote down on the blackboard to be slow so you can see this. 

这是你们第一次见到这么复杂的程序
This is the first time you've seen something quite this complicated, I think. 

我们还是需要在幻灯片上看一下整个程序
However, we might want to see the whole thing over here in this transparency or slide or whatever. 

这里详细地写出了程序所有需要的细节
What we have is all of the details that are required to make this thing work. 

在这里，我在close-enuf过程里给出了误差
I have a way of getting a tolerance for a close enough procedure, which we see here. 

close-enuf过程通过比较u和v差的绝对值是否小于给定的误差，来确定u和v是否足够接近
The close enough procedure, it tests whether u and v are close enough by seeing if the absolute value of the difference in u and v is less than the given tolerance, OK? 

这里是我刚才在黑板上写出的循环定义
And here is the iteration loop that I just wrote on the blackboard 

它的初始化调用在这
and the initialization for it, which is right there. 

这很容易理解
It's very simple.

其实，我还没有说完
But let's see. I haven't told you enough. 

实际上这个程序可以更简单
It's actually easier than this. 

对于这个问题，在我讲述的内容背后隐含着更多的原理支撑
There is more structure to this problem than I've already told you. 

比如为什么这个方法可行
Like why should this work? 

为什么它会收敛
Why should it converge? 

在这个程序的背后有复杂的数学原理支撑
There's a hairy theorem in mathematics tied up in what I've written here. 

为什么我可以认为迭代计算(y+x/y)/2的值就能得到正确的结果
Why is it that I should assume that by iterating averaging the quotient of x and y and y that I should get the right answer? 

这些问题的答案都不明显
It isn't so obvious.

当然，除此之外，还会有其他的计算不动点的方法，也能得到平方根的值
Surely there are other things, other procedures, which compute functions whose fixed points would also be the square root. 

比如，很明显的，函数g
For example, the obvious one will be a new function g, 

它将y映射为x/y
which maps y to x/y. 

这甚至更简单
That's even simpler. 

函数g的不动点显然也是平方根的值
The fixed point of g is surely the square root also, 

并且它使更为简单的过程
and it's a simpler procedure.

为什么我不使用这种方法呢？
Why am I not using it? 

显而易见
Well, I suppose you know. 

假设x是2
Supposing x is 2 

并且猜测的初值是1
and I start out with 1, 

我将2除以1，得到2
and if I divide 1 into 2, I get 2. 

然后我将2除以2，得到1
And then if I divide 2 into 2, I get 1. 

再将2除以1得到2，2除以2得到1……
If I divide 1 into 2, I get 2, and 2 into 2, I get 1, 

这样，我永远也接近不了2的平方根
and I never get any closer to the square root. 

它在真实值上下摆动
It just oscillates. 

实际上，这相当于一个信号处理系统
So what we have is a signal processing system, 

一个振荡的电路
an electrical circuit which is oscillating, 

我想要减小振荡的振幅
and I want to damp out these oscillations. 

当然，我可以做到这点
Well, I can do that.

在这里，我实际上用到的是平均值
See, what I'm really doing here when I'm taking my average, 

计算的是某个振荡的均值
the average is averaging the last two values of something which oscillates, 

得到了中间的某个值
getting something in between. 

传统的方法是在信号处理系统中添加阻尼
The classic way is damping out oscillations in a signal processing system. 

为什么我们不把刚才讲的策略用一种更清晰的方式表达呢？
So why don't we write down the strategy that I just said in a more clear way? 

其实，这并不那么复杂
Well, that's easy enough.

将根号x的值定义为
I'm going to define the square root of x to be 

用平均阻尼的方法得到的某个过程的不动点
a fixed point of the procedure resulting from average damping. 

即将average-damp应用于过程
So I have a procedure resulting from average damp 

λ (y) (/ x y)
of the procedure, that procedure of y, which divides x by y 

初始猜测值为1
starting out at 1. 

average-damp是一个特殊的过程
Ah, but average damp is a special procedure 

它的参数是一个过程
that's going to take a procedure as its argument 

其返回值也是一个过程
and return a procedure as its value. 

具体来说
It's a generalization that says 

给定一个过程
given a procedure, 

它产生出另一个过程
it's the thing which produces a procedure 

用于计算出某一个值在给定的过程作用下之后产生的值
which averages the last value and the value 

与它原来大小的平均值
before and after running the procedure. 

你可以在任何需要平均阻尼技术的地方使用它
You can use it for anything if you want to damp out oscillations. 

我们把它编写出来
So let's write that down. 

这很简单
It's very easy.

在语法上
And stylistically here, 

我要使用lambda表达式
I'm going to use lambda notation 

因为当你的处理对象是过程的时候
because it's much easier to think when you're dealing with procedure, the mid-line procedures, 

这种记法会更易于你的理解
to understand that the procedures are the objects I'm dealing with, 

所以在这里我打算使用lambda表达式
so I'm going to use lambda notation here.  

我并不是经常使用它
Not always. I don't always use it, 

但用在这个过程里来阐明自己的想法是非常合适的
but very specifically here to expand on that idea, to elucidate it.

average-damp这个过程
Well, average damp is a procedure, 

将一个过程作为自己的参数，记作f
which takes a procedure as its argument, which we will call f. 

它产生什么呢？
And what does it produce? 

这个过程产生的是一个过程
It produces as its value-- the body of this procedure is a thing which produces a procedure, 

产生的过程主体从这里开始
the construct of the procedures right here, 

拥有一个参数x
of one argument x, 

并计算出f(x)和x的平均值
which averages f of x with x.

这是一个很神奇的过程
This is a very special thing. 

我猜这是你们第一次见到一个过程产生出另一个过程作为其结果
I think for the first time you're seeing a procedure which produces a procedure as its value. 

这个过程接受了过程f，做了一些工作
This procedure takes the procedure f and does something to it 

产生出一个新的过程，拥有一个参数x
to produce a new procedure of one argument x, 

计算出f...
which averages f

这里的f
-- this f-- 

f(x)和x的平均值
applied to x and x itself. 

在代码的这个部分
Using the context here, 

我将average-damp应用到过程x/y上
I apply average damping to the procedure, which just divides x by y. 

就是个除法
It's a division. 

接着再找到这个过程的不动点
And I'm finding to fixed point of that, 

这个写法更清晰的阐明了整个过程，较之于先前这里的写法
and that's a clearer way of writing down what I wrote down over here, 

我找找...
wherever it was. 

先前这里的写法
Here, 

因为它做出了更进一步的抽象
because it tells why I am writing this down.

我希望以上这些能在一定程度上阐明Heron-Alexandria方法
I suppose this to some extent really clarifies what Heron of Alexandria was up to. 

先到此为止吧，有什么问题吗？
I suppose I'll stop now. Are there any questions?

观众：在你定义average-damp过程的时候
AUDIENCE: So when you define average damp, 

不需要给f一个变量吗？
don't you need to have a variable on f?

教授：啊，你的问题是...
PROFESSOR: Ah, the question was, and here we're having-- again, 

你应该已经了解语法了
you've got to learn about the syntax. 

你的问题是当定义average-damp的时候
The question was when defining average damp, 

是否需要给f一个变量？
don't you have to have a variable defined with f?

你的意思是提供f的形式参数？
What you are asking about is the formal parameter of f?

观众：是的
AUDIENCE: Yeah.

教授：好的
PROFESSOR: OK. 

f的形式参数其实是在这里
The formal parameter of f is here. 

f的形式参数...
The formal parameter of f--

观众：我指的是average-damp的形式参数
AUDIENCE: The formal parameter of average damp.

教授：f在这里被应用到了一个参数上，对吗？
PROFESSOR: F is being used to apply it to an argument, right? 

实际上f确实需要一个形式参数
It's indeed true that f must have a formal parameter. 

我们来找一下f的形式参数在哪
Let's find out what f's formal parameter is.

观众：我想问的是average-damp的形式参数
AUDIENCE: The formal parameter of average damp.

教授：哦，f应该是average-damp的形式参数
PROFESSOR: Oh, f is the formal parameter of average damp. 

抱歉
I'm sorry. 

你被一些语法混淆了
You're just confusing a syntactic thing. 

我应该用换一种方式写
I could have written this the other way. 

我已经明白你的问题了
Actually, I didn't understand your question. 

我应该用这种方式写
Of course, I could have written it this other way. 

它们是一样的
Those are identical notations. 

这是另一种写法
This is a different way of writing this. 

你得习惯这种lambda记法
You're going to have to get used to lambda notation 

我以后也会使用
because I'm going to use it.

在这里
What it says here, 

我定义了average-damp这个过程
I'm defining the name average damp 

来给这个拥有一个参数f的过程命名
to name the procedure whose of one argument f. 

这个f就是average-damp过程的形式参数
That's the formal parameter of the procedure average damp. 

这个define的作用是赋予这个名字一个值
What define does is it says give this name a value. 

这里就是这个值
Here is the value of for it. 

这是个有趣的语法
That there happens to be a funny syntax 

在一些情况下能带来一些便利
to make that easier in some cases is purely convenience. 

我在这里使用这种写法的原因
But the reason why I wrote it this way here 

是为了强调我处理的过程
is to emphasize that I'm dealing with a procedure 

接受了一个过程作为参数
that takes a procedure as its argument 

并且产生出另一个过程作为值
and produces a procedure as its value.

观众：我不太理解你为什么使用两次lambda
AUDIENCE: I don't understand why you use lambda twice. 

难道不能使用一个lambda，以f和x作为参数吗？
Can you just use one lambda and take two arguments f and x?

教授：不能
PROFESSOR: No.

观众：不能？
AUDIENCE: You can't?

教授：不，那是不同的东西了
PROFESSOR: No, that would be a different thing. 

如果我在这里写成
If I were to write the procedure  

(λ (f x) (average (f x) x))
lambda of f and x, the average of f of x and x, 

那么它就不能接受一个过程作为参数
that would not be something which would be allowed to take a procedure as an argument 

并且产生一个过程作为值了
and produce a procedure as its value. 

它就成为接受一个参数以及一个数字作为它的参数
That would be a thing that takes a procedure as its argument and numbers its argument 

并且产生出的是一个新的数
and produces a new number. 

而在这里我需要一个过程
But what I'm producing here is a procedure 

来作为这个过程的参数
to fit in the procedure slot over here, 

并且在这里使用
which is going to be used over here. 

所以数字必须来自这里
So the number has to come from here. 

最后直到这里才用上x
This is the thing that's going to eventually end up in the x. 

如果你仍然很迷惑
And if you're confused, 

你可以自己做一些代换
you should do some substitution and see for yourself. 

什么问题？
Yes?

观众：你可以展示一下如何不用lambda表达式
AUDIENCE: Will you please show the definition for average damp 

来定义average-damp过程吗？
without using lambda notation in both cases.

教授：那样就无法如此简练地实现了
PROFESSOR: I can't make a very simple one like that. 

我来定义给你看
Let me do it for you, though. 

我可以很容易地去掉这个lambda
I can get rid of this lambda easily. 

我不希望...
I don't want to be-- 

好吧，我说谎了
actually, I'm lying to you. 

我不想照你那样去实现
I don't want to do what you want 

因为这会远比你想象的复杂
because I think it's more confusing than you think. 

我就不去实现你的想法了
I'm not going to write what you want.

这里得起个名字
So we'll have to get a name. 

(FOO x)为...
FOO of x to be 

...(F x)和x
of F of x and x 

返回值是FOO
and return as a value FOO. 

这个是等价的写法
This is equivalent, 

但我还得另写一个冗余的变量名
but I've had to make an arbitrary name up. 

这两个是等价的，但没有使用lambda
This is equivalent to this without any lambdas. 

lambda非常适合于需要匿名过程的地方
Lambda is very convenient for naming anonymous procedures. 

用它来代表一些匿名的事物
It's the anonymous name of something. 

其实存在着更优美的解决方法
Now, if you really want to know a cute way of doing this, 

我们以后会提到
we'll talk about it later. 

匿名过程的定义还是必要的
We're going to have to define the anonymous procedure. 

有其它问题吗？
Any other questions? 

休息一下吧
And so we go for our break again.

我们现在已经了解了如何使用高阶过程
So now we've seen how to use high-order procedures, they're called. 

用来接受过程参数和产生过程结果
That's procedures that take procedural arguments and produce procedural values 

来帮助我们阐明和抽象一些复杂的过程
to help us clarify and abstract some otherwise complicated processes. 

我现在打算用它来做一些更有趣的事情
I suppose what I'd like to do now is have a bit of fun with that 

也同时作为练习
and sort of a little practice as well. 

我们来更深入地研究一下square-root过程
So let's play with this square root thing even more. 

详尽地剖析和理解其中的工作方式
Let's elaborate it and understand what's going on 

并且利用一下它的代码结构
and make use of this kind of programming style.

有件事你们已经知道
One thing that you might know is that 

有一个通用的方法叫做Newton法
there is a general method called Newton's method 

用来计算函数的根
for the purpose of which is to find the roots-- 

也就是函数的零点
that's the zeroes-- of functions. 

举个例子
So, for example, 

求y，使得f(y)等于0
to find a y such that f of y equals 0, 

首先要从一个猜测值开始
we start with some guess. 

这就是Newton法
This is Newton's method. 

将初始的猜测值命名为y_0
And the guess we start with we'll call y0, 

然后我们迭代地计算下面这个表达式
and then we will iterate the following expression.

y_{n+1}...
y n plus 1-- 

这是另外一个方程
this is a difference equation-- 

等于y_n - f(y_n)
is yn minus f of yn 

除以f对y的导数
over the derivative with respect to y of f 

在y = y_n点处的值
evaluated at y equal yn. 

非常奇怪的式子
Very strange notation. 

我得说...
I must say ugh. 

f对y的求导得到的是一个函数
The derivative of f with respect to y is a function. 

感觉上会有些麻烦
I'm having a little bit of unhappiness with that, 

不过没关系
but that's all right. 

在用程序语言表达以后
It turns out in the programming language world, 

会变得非常清晰
the notation is much clearer.

这是什么？
Now, what is this? 

这就是所谓的Newton法
People call it Newton's method. 

它用来计算函数f的根
It's a method for finding the roots of the function f. 

当收敛的时候，它会计算得很快
And it, of course, sometimes converges, and when it does, it does so very fast. 

不过有时是不收敛的
And sometimes, it doesn't converge, and,

那样我们就需要做一些其它的工作
oh well, we have to do something else. 

先让我们来讨论一下用Newton法计算平方根
But let's talk about square root by Newton's method.

这会很有趣
Well, that's rather interesting. 

我们先使用一下之前用到过的方法
Let's do exactly the same thing we did last time: 

按愿望思维的方法
a bit of wishful thinking. 

假设我们已经实现了Newton法
We will apply Newton's method, 

可以直接使用它
assuming we knew how to do it. 

事实上你还并未实现
You don't know how to do it yet. 

让我们开始吧
Well, let's go.

这里要写什么？SQRT x（x的平方根）
What do I have here? The square root of x. 

将Newton法应用到某个作用在y上的过程上
It's Newton's method applied to a procedure which will represent that function of y, 

这个过程用于计算y对应的函数值
which computes that function of y. 

这个过程参数是y
Well, that procedure is that procedure of y, 

计算出x和根号y的差
which is the difference between x and the square of y. 

实际上，如果存在y使得这个式子等于0
Indeed, if I had a value of y for which this was zero, 

那么y就是x的平方根
then y would be the square root of x. 

明白吗？
See that? 

接下来，我令其从1开始尝试
OK, I'm going to start this out searching at 1. 

这完全是一个随意写下的猜测值
Again, completely arbitrary property of square roots that I can do that.

现在的问题是，Newton法应该如何实现？
Now, how am I going to compute Newton's method? 

方法的过程在这里书写了
Well, this is the method I have it right here. 

实际上，我所做的是寻找某个过程的不动点
In fact, what I'm doing is looking for a fixed point of some procedure. 

这个过程包含了一些复杂的表达式
This procedure involves some complicated expressions 

和一些其它的怪东西
in terms of other complicated things. 

我就是要找到这个式子的不动点
Well, I'm trying to find the fixed point of this. 

我要找到某个y的值
I want to find the values of y, 

使得在这里带入这个值后，得到的是相同的值
which if I put y in here, I get the same value out here 

考虑在一定的误差范围内
up to some degree of accuracy. 

好在我已经有一个计算不动点的过程了
Well, I already have a fixed point process around to do that. 

我们在这里开始定义Newton法
And so, let's just define Newton's method over here.

这个过程需要一个函数和一个猜测值
A procedure which computes a function and a guess, 

初始的猜测值
initial guess. 

我接下来要做一件事
Now, I'm going to have to do something here. 

要计算出函数的导数
I'm going to need the derivative of the function. 

我需要一个过程来计算出函数的导数
I'm going to need a procedure which computes the derivative 

给出的函数由过程f来计算
of the function computed by the given a procedure f. 

我接下来会讲的很仔细
I'm trying to be very careful about what I'm saying. 

我不想混淆“过程”和“函数”这两个词
I don't want to mix up the word procedure and function. 

函数是数学术语
Function is a mathematical word. 

将一个值映射到另一个值
It says I'm mapping from values to other values, 

有序偶的集合之类的
a set of ordered pairs. 

但有时我也会不小心说岔
But sometimes, I'll accidentally mix those up. 

而过程是用来计算函数的
Procedures compute functions.

我将DF定义为...
So I'm going to define the derivative of f 

再使用一下按愿望思维
to be by wishful thinking again. 

先不管具体如何实现
I don't know how I'm going to do it. 

我们之后再讨论
Let's worry about that later-- 

f的导数
of F. 

F是一个过程
So if F is a procedure, 

在这里的情况指的是开根号
which happens to be this one over here for a square root, 

DF就是其的导数
then DF will be the derivative of it, 

也就是由过程F计算的函数的导数
which is also the derivative of the function computed by that procedure. 

DF就是一个计算由过程F计算的函数的导数过程
DF will be a procedure that computes the derivative of the function computed by the procedure F. 

定义好这个之后，我就要来寻找一个不动点
And then given that, I will just go looking for a fixed point.

我要寻找的不动点是什么的呢？
What is the fixed point I'm looking for? 

这个过程有一个参数x
It's the one for that procedure of one argument x, 

计算出x减...
which I compute by subtracting x. 

x是先前的值，相当于那里的y_n
That's the old-- that's the yn here. 

f(x)和df(x)的商
The quotient of f of x and df of x,

从原始的猜测值开始
starting out with the original guess. 

整个看上去很简单
That's all very simple.

现在，我还有一个部分没有写
Now, I have one part left that I haven't written, 

我先需要你们回顾一下我整个的实现流程
and I want you to see the process by which I write these things, 

这在实际经验中是很实用的
because this is really true. 

首先我拥有数学的猜想
I start out with some mathematical idea, perhaps. 

通过按愿望思维
By wishful thinking, I assume 

我假设我已经拥有了一些魔法可以实现一些过程
that by some magic I can do something that I have a name for. 

先不关心到底如何去实现它们
I'm not going to worry about how I do it yet. 

然后再继续
Then I go walking down here and say, well, 

通过这些魔法，我大致实现了整个过程
by some magic, I'm somehow going to figure how to do that, 

即使还未实现某些方法
but I'm going to write my program anyway. 

这种按愿望思维，对于工程来说是很重要的
Wishful thinking, essential to good engineering, 

同样，对于计算机科学也是很重要的
and certainly essential to a good computer science.

那么，有多少人想让你的计算机运行得更快？
So anyway, how many of you wished that your computer ran faster? 

求导过程的实现并不会很困难
Well, the derivative isn't so bad either. 

有点类似于average-damping过程
Sort of like average damping. 

DERIV求导过程接受一个用于计算函数值的过程
The derivative is a procedure that takes a procedure that computes a function as its argument, 

然后产生一个过程
and it produces a procedure that computes a function, 

接受一个参数x
which needs one argument x. 

你们应该都清楚导数的定义
Well, you all know this definition. 

是(f(x + dx) - f(x)) / dx， 对吗？
It's f of x plus delta x minus f of x over delta x, right? 

dx是一个很小的值
For some small delta x. 

即(/ (- (f (+ x dx)) (f x)) dx)
So that's the quotient of the difference of f of the sum of x and dx minus f point x divided by dx. 

我希望括号没有匹配错误
I think the thing was lining up correctly when I balanced the parentheses.

我希望你们看一下这个
Now, I want you to look at this. 

仔细的观察一下
Just look. 

我应该还没定义dx
I suppose I haven't told you what dx is. 

我会在其它某个地方写下
Somewhere in the world I'm going to have to write down 

这样的定义
something like that. 

这无关紧要
I'm not interested. 

这个过程接受一个过程然后产生出一个近似过程
This is a procedure which takes a procedure and produces an approximation, 

这个近似过程用于计算出某个函数的导数，函数是由给定的过程计算的
a procedure that computes an approximation of the derivative of the function computed by the procedure given 

其中使用了大家熟悉的求导方法
by the standard methods that you all know and love.

也许这并不是一个很好的估算导数的方法
Now, it may not be the case that doing this operation is such a good way of approximating a derivative. 

数值分析学家可能会跳出来对我说
Numerical analysts here should jump on me and say 

不要那样做！
don't do that. 

计算机求导确实会带来一定的误差
Computing derivatives produces noisy answers, which is true. 

然而这只是用于理解整个过程
However, this again is for the sake of understanding. 

回顾一下
Look what we've got. 

我们首先起手于一个复杂的数学方法
We started out with what is apparently a mathematically complex thing. 

写满的几个黑板中
and in a few blackboards full, 

我们试图将这个求根号的问题分解
we managed to decompose the problem of computing square roots 

通过你们在数值课程中学到的Newton法
by the way you were taught in your college calculus class-- Newton's method-- 

分解以后就能很容易处理了
so that it can be understood. 

变得清晰了
It's clear.

看一下求解的整个结构
Let's look at the structure of what it is we've got. 

请看一下幻灯片
Let's look at this slide. 

这是黑板上描述的程序的流程图
This is a diagram of the machine described by the program on the blackboard. 

描述了机器执行的过程
There's a machine described here. 

有哪些部分呢？
And what have I got? 

这个部分代表了Newton法中的函数f
Over here is the Newton's method function f 

写在了黑板的最左面
that we have on the left-most blackboard. 

它接受了一个参数y
It's the thing that takes an argument called y 

计算出x与根号y的差
and puts out the difference between x and the square of y, 

通过某种魔法，x作为自由变量从外部进入
where x is some sort of free variable that comes in from the outside by some magic. 

所以square-root过程需要获取到x的值
So the square root routine picks up an x, 

并给定这个过程
and builds this procedure, 

x就被替换到内部的过程中
which I have the x rolled up in it by substitution.

云中的这个过程被作为参数f
Now, this procedure in the cloud is fed in as the f 

传递进这个框中的Newton法
into the Newton's method which is here, this box. 

f在这里有两个去向
The f is fanned out. 

一是被用作参数传递
Part of it goes into something else, 

二是被应用到求导过程中，再将求导结果传递
and the other part of it goes through a derivative process into something else 

来产生一个新的过程
to produce a procedure,

产生出的过程作为计算Newton法的迭代函数的过程
which computes the function which is the iteration function of Newton's method 

最后将其应用到求不动点的方法上
when we use the fixed point method. 

所以这个过程
So this procedure, 

通过代换使用了（f和df）
which contains it by substitution-- 

记住，是这里的Newton法构造出了这个过程
remember, Newton's method over here, Newton's method builds this procedure, 

并且是在Newton法中定义了f和df
and Newton's method has in it defined f and df, 

所以，f和df在这里被捕获
so those are captured over here: f and df. 

利用这个过程
Starting with this procedure, 

传递进fixed-point过程里
I can now feed this to the fixed point process 

再利用从square-root外传递进的初始的猜测值
within an initial guess coming out from the outside from square root 

来计算出x的平方根
to produce the square root of x. 

于是我们就制造出了一个强大的引擎
So what we've built is a very powerful engine, 

通过它我们可以制造出类似的优美的东西
which allows us to make nice things like this.

最后，我想使用Chris Strachey提出的一个基本思想作为结束
Now, I want to end this with basically an idea of Chris Strachey, 

他是计算机科学之父之一
one of the grandfathers of computer science.

他是一位逻辑学家，大概...
He's a logician who lived in the-- 

大概10到15年前他去世了
I suppose about 10 years ago or 15 years ago, he died. 

我记不太清了
I don't remember exactly when. 

他是指称语义学的发明者之一
He's one of the inventors of something called denotational semantics. 

他是将过程或是函数视为程序设计语言中的第一级元素的最主要的提倡者
He was a great advocate of making procedures or functions first-class citizens in a programming language.

这些是程序设计语言中的第一级元素的某些权利或者特权
So here's the rights and privileges of first-class citizens in a programming language. 

如果你想要做出任何你想要做出的抽象
It allows you to make any abstraction you like 

那么将函数视为第一级元素是必须的
if you have functions as first-class citizens. 

第一级元素必须能够可以用变量命名
The first-class citizens must be able to be named by variables. 

你们已经见过我这样做过很多次
And you're seeing me doing that all the time. 

这里是将某个过程作为变量命名的例子
Here's a nice variable which names a procedure which computes something. 

他们必须可以被提供给过程作为参数
They have to be passed as arguments to procedures. 

我们之前见过这种情况了
We've certainly seen that. 

他们可以由过程作为结果返回
We have to be able to return them as values from procedures.

我们也应该见过了
And I suppose we've seen that. 

我们还没有见过关于数据结构的内容
We haven't yet seen anything about data structures. 

我们之后会讨论的
We will soon, 

这也是作为程序设计语言的第一级元素必要的性质
but it's also the case that in order to have a first-class citizen in a programming language, 

它们可以包含在数据结构中
the object has to be allowed to be part of a data structure. 

我们马上就会见到
We're going to see that soon.

所以就先到此为止吧
So I just want to close with this 

我们见识到了像过程这样的第一级元素
and say having things like procedures as first-class data structures, first-class data, 

可以带来如此强大的抽象能力
allows one to make powerful abstractions, 

像Newton法这样的通用方法可以被非常清晰地编写出来
which encode general methods like Newton's method in very clear way. 

有什么问题吗？
Are there any questions? 

请
Yes.

观众：DERIV F可以直接写到fixed-point方法中取代df吗
AUDIENCE: Could you put derivative instead of df directly in the fixed point?

教授：哦，当然
PROFESSOR: Oh, sure. 

当然可以直接把DERIV F放到这里
Yes, I could have put deriv of f right here, 

没有问题
no question. 

每当你见到定义了什么东西
Any time you see something defined, 

你就可以直接把定义写到这里
you can put the thing that the definition is there 

你会得到相同的结果
and you should get the same result. 

实际上，那样就会看上去很有趣
In fact, what that would look like, it's interesting.

观众：lambda
AUDIENCE: Lambda.

教授：嗯？
PROFESSOR: Huh?

观众：你可以把lambda表达式写在那
AUDIENCE: You could put the lambda expression in there.

教授：我也可以把DERIV F写在这
PROFESSOR: I could also put derivative of f here. 

这看上去会很有意思
It would look interesting 

即((DERIV F) x)
because of the open paren, open paren, deriv of f, closed paren on an x. 

那样就会冗余地重复计算导数
Now, that would have the bad property of computing the derivative many times, 

因为每当我执行这个过程的时候
because every time I would run this procedure, 

都要重新计算导数
I would compute the derivative again. 

这里的两个左括号都有意义
However, the two open parens here both would be meaningful. 

我希望你们理解这里细节的语法
I want you to understand syntactically that that's a sensible thing. 

如果我重写这个程序
Because if was to rewrite this program-- 

在这里按照你的想法重写
and I should do it right here just so you see 

这是一个好问题
because that's a good question-- 

...F和GUESS
of F and guess 

结果是求参数为x
to be fixed point of that procedure of one argument x, 

结果为(- x (/ (f x)((DERIV F) x)))的过程的不动点
which subtracts from x the quotient of F applied to x and the deriv of F applied to x. 

这里是GUESS
This is guess.

这是一个完全正确的程序
This is a perfectly legitimate program, 

因为在这里...
because what I have here-- 

记住求值规则
remember the evaluation rule. 

求值规则是求值每个组合式的所有部分
The evaluation rule is evaluate all of the parts of the combination:

包括运算符和运算对象
the operator and the operands. 

这是这个组合式的运算符
This is the operator of this combination. 

求值这个运算符会产生F的导数
Evaluating this operator will, of course, produce the derivative of F.

观众：甚者，是否可以在那里写成lambda表达式
AUDIENCE: To get it one step further, you could put the lambda expression there, too.

教授：哦当然
PROFESSOR: Oh, of course. 

每当我在某处使用了定义好的东西
Any time I take something which is define, 

我也可以将其替换成它定义的具体内容
I can put the thing it's defined to be in the place where the thing defined is. 

不用去区分哪个是被定义项，哪个是定义项
I can't remember which is definiens and which is definiendum. 

每当我在思考如何在课堂上向新手解释这个问题
When I'm trying to figure out how to do a lecture about this in a freshman class, 

我觉得这种概念游戏是很有意思的
I use such words and tell everybody it's fun to tell their friends. 

那么就到此为止吧
OK, I think that's it.


MIT OpenCourseWare
http://ocw.mit.edu
6.001 Structure and Interpretation of Computer Programs, Spring 2005 Please use the following citation format:
Eric Grimson, Peter Szolovits, and Trevor Darrell, 6.001 Structure and Interpretation of Computer Programs, Spring 2005. (Massachusetts Institute of Technology: MIT OpenCourseWare). http://ocw.mit.edu (accessed MM DD, YYYY). License: Creative Commons Attribution-Noncommercial-Share Alike.
Note: Please use the actual date you accessed this material in your citation.
For more information about citing these materials or our Terms of Use, visit:
http://ocw.mit.edu/terms
￼￼￼